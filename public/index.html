
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>NIMBY Rail Clone - 鉄道＆航空シミュレーション</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <style>
      /* 基本スタイル */
      body {
        margin: 0;
      }
      #map {
        height: 100vh;
        width: 100%;
        background-color: white;
      }

      .rail-ui-control,
      #game-stats,
      #login-overlay,
      #ranking-panel,
      #chat-panel,
      #news-feed-panel {
        background-color: rgba(255, 255, 255, 0.95);
        padding: 10px;
        border: 2px solid #333;
        border-radius: 5px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        font-family: Arial, sans-serif;
        z-index: 1000;
        position: fixed;
      }

      /* ログインオーバーレイ */
      #login-overlay {
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 2000;
      }
      #login-panel {
        background-color: white;
        padding: 30px;
        border-radius: 8px;
        text-align: center;
      }

      /* UIコントロールのスタイル修正: スクロール可能にする */
      .rail-ui-control {
        top: 10px;
        left: 10px;
        width: 300px;
        max-height: 85vh; 
        overflow-y: auto; 
      }

      /* ニュースフィードパネル (左下) */
      #news-feed-panel {
        bottom: 10px;
        left: 10px;
        width: 300px;
        max-height: 200px;
        overflow-y: auto;
        font-size: 0.9em;
      }

      /* UIコンソール位置 (右上) */
      #game-stats {
        top: 10px;
        right: 10px;
        width: 300px;
        line-height: 1.5;
      }
      
      /* チャットパネル位置 (右下) */
      #chat-panel {
        bottom: 10px;
        right: 10px;
        width: 300px;
        max-height: 240px;
      }
      
      /* ランキングパネル位置 (チャットパネルの上) */
      #ranking-panel {
        bottom: 250px; 
        right: 10px;
        width: 300px;
        max-height: 240px;
        overflow-y: auto;
      }

      /* アコーディオンヘッダー */
      .accordion-header {
        cursor: pointer;
        background-color: #f0f0f0;
        padding: 5px;
        border-bottom: 1px solid #ccc;
        font-weight: bold;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .accordion-content {
        padding-top: 10px;
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease-in-out;
      }
      .accordion-content.open {
        max-height: none;
      }

      /* ボタン・セレクト */
      .rail-ui-control button,
      .rail-ui-control select,
      #loan-panel button {
        padding: 8px 12px;
        font-size: 14px;
        cursor: pointer;
        border: 1px solid #555;
        background-color: #f5f5f5;
        border-radius: 3px;
        margin: 2px 0;
        width: 100%;
        box-sizing: border-box;
      }
      .rail-ui-control button.active {
        background-color: #007bff !important;
        color: white;
        border-color: #0056b3;
      }
      .time-display {
        font-size: 1.2em;
        font-weight: bold;
        color: #0044bb;
        margin-bottom: 10px;
      }

      /* 列車アイコンの調整: 丸から長方形に変更 */
      .train-icon {
        width: 18px; 
        height: 8px; 
        border-radius: 2px; 
        border: 2px solid #fff;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
        transform: translate(-50%, -50%); 
      }
      .station-icon {
        background-color: #000;
        width: 15px;
        height: 15px;
        border-radius: 50%;
        border: 3px solid #fff;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
        cursor: pointer;
      }
      
      /* 動的な駅アイコンカラー */
      .station-icon.normal { background-color: #0044BB; }
      .station-icon.overload { background-color: #FF0000; }
      .station-icon.demand { background-color: #FFCC00; }

      /* 空港アイコン */
      .airport-icon {
        background-color: #007bff;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        border: 3px solid #fff;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
        cursor: pointer;
        text-align: center;
        line-height: 14px;
        font-size: 12px;
        color: white;
        font-weight: bold;
      }
      
      /* 動的な空港アイコンカラー */
      .airport-icon.normal { background-color: #007bff; }
      .airport-icon.overload { background-color: #FF0000; }

      /* 飛行機アイコン (回転対応) */
      .airplane-icon {
        width: 24px; 
        height: 24px;
        background-color: #5bc0de; 
        border-radius: 2px; 
        border: 2px solid #fff;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
        clip-path: polygon(
            50% 0%, 
            60% 25%, 
            100% 50%, 
            60% 75%, 
            50% 100%, 
            40% 75%, 
            0% 50%, 
            40% 25%
        ); 
        transform: translate(-50%, -50%);
        transform-origin: 50% 50%; 
      }
      
      .leaflet-container.station-mode,
      .leaflet-container.airport-mode {
        cursor: crosshair;
      }
      .leaflet-container.dismantle-station-mode .station-icon {
        border-color: #ff0000;
        cursor: crosshair;
      }
      .leaflet-container.dismantle-line-mode {
        cursor: crosshair;
      }

      #error-message,
      #info-message {
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 3000;
        display: none;
      }
      #error-message {
        background-color: #ff4444;
        color: white;
      }
      #info-message {
        background-color: #44aaff;
        color: white;
      }
      
      /* ========================================================= */
      /* UI重なり防止のためのメディアクエリ */
      /* ========================================================= */
      @media (max-width: 650px) {
        .rail-ui-control,
        #game-stats,
        #ranking-panel,
        #chat-panel,
        #news-feed-panel {
            width: 95%;
            left: 2.5%;
            right: auto;
            position: relative; 
            margin-bottom: 10px;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-bottom: 260px; 
        }
        
        #map {
            position: fixed;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%;
            z-index: 0;
        }

        /* 建設コントロール (左上 -> 上部全体) */
        .rail-ui-control {
            top: 10px;
            max-height: 40vh; 
            z-index: 1001;
        }

        /* 統計情報 (右上 -> 建設の下) */
        #game-stats {
            top: auto;
            right: auto;
            z-index: 1001;
        }

        /* ニュースフィード (左下 -> 統計の下) */
        #news-feed-panel {
            top: auto;
            left: 2.5%;
            right: auto;
            z-index: 1001;
        }
        
        /* ランキングとチャットは画面下部に固定 */
        #ranking-panel,
        #chat-panel {
            position: fixed;
            width: 95%;
            left: 2.5%;
            right: auto;
            z-index: 1002;
        }

        /* ランキング (チャットの上) */
        #ranking-panel {
            bottom: 130px;
            max-height: 120px;
        }

        /* チャット (最下部) */
        #chat-panel {
            bottom: 10px;
            max-height: 120px;
        }
        
        #chat-messages {
            height: 50px !important;
        }
      }
    </style>
  </head>
  <body>
    <div id="map"></div>

    <!-- ログインオーバーレイ -->
    <div id="login-overlay">
      <div id="login-panel">
        <h2>オンライン鉄道＆航空シムへようこそ</h2>
        <p>
          ランキングに参加するため、ユーザー名とパスワードを入力してください。<br /><small
            >（新規ユーザーは任意のパスワードで登録できます）</small
          >
        </p>
        <input
          type="text"
          id="username-input"
          placeholder="ユーザー名"
          style="padding: 10px; margin-bottom: 10px; width: 80%"
        />
        <input
          type="password"
          id="password-input"
          placeholder="パスワード"
          style="padding: 10px; margin-bottom: 10px; width: 80%"
        />
        <button onclick="handleLogin()" style="width: 80%">
          ログイン / 参加
        </button>
      </div>
    </div>

    <!-- ゲーム統計 (右上) -->
    <div id="game-stats">
      <div class="accordion-header" onclick="toggleAccordion('stats-content')">
        <span>📊 ゲーム統計・時間 <span id="stats-toggle-icon">▼</span></span>
      </div>
      <div id="stats-content" class="accordion-content open">
        <p class="time-display">
          日時: <span id="game-date-time">同期中...</span>
        </p>
        <p>倍速: <span id="time-scale-display">x60</span> (サーバー制御)</p>
        <hr />
        <h3>💰 経営状況 (あなた)</h3>
        <p>資金: <span id="money-display">¥0</span></p>
        <p>総資産: <span id="asset-display">¥0</span></p>
        <p>月次維持費: <span id="maint-cost-display">¥0</span></p>
        <p>月次返済額: <span id="loan-repayment-display">¥0</span></p>
        <p>
          車両数: <span id="vehicle-count">0</span> | ターミナル数:
          <span id="terminal-count">0</span>
        </p>
      </div>
    </div>
    
    <!-- ニュースフィードパネル (左下) -->
    <div id="news-feed-panel">
        <div class="accordion-header" onclick="toggleAccordion('news-content')">
            <span>📰 ニュースフィード <span id="news-toggle-icon">▼</span></span>
        </div>
        <div id="news-content" class="accordion-content open" style="max-height: 150px; overflow-y: auto;">
            <ul id="news-list" style="list-style: none; padding: 0; margin: 0;">
                <li>システム: ゲーム開始！</li>
            </ul>
        </div>
    </div>

    <!-- 建設・車両コントロール (左上) -->
    <div class="rail-ui-control">
      <div
        class="accordion-header"
        onclick="toggleAccordion('control-content')"
      >
        <span>🛠️ 建設・車両操作 <span id="control-toggle-icon">▼</span></span>
      </div>
      <div id="control-content" class="accordion-content open">
        <div style="text-align: center; margin-bottom: 10px">
          
          <!-- 融資パネル -->
          <hr style="margin: 10px 0; border: none; border-top: 2px solid #888;" />
          <h3>🏦 銀行融資</h3>
          <div id="loan-panel">
            <p>現在の借入: <span id="current-loan-display">¥0</span></p>
            <p>借入可能額: <span id="max-loan-display">¥0</span></p>
            <input type="number" id="loan-amount-input" placeholder="借入希望額 (M)" style="width: 48%; display: inline-block;">
            <input type="number" id="loan-term-input" placeholder="期間 (月)" style="width: 48%; display: inline-block;">
            <button onclick="requestLoan()">融資を申し込む</button>
          </div>
          
          <!-- 建設コスト詳細 -->
          <div id="construction-info" style="margin-top: 10px; padding: 5px; border: 1px solid #ccc; display: none;">
            <b>建設予定:</b>
            <p>距離: <span id="construction-distance">0.0 km</span></p>
            <p>概算コスト: <span id="construction-cost">¥0</span></p>
            <p>地形補正: <span id="construction-terrain">0%</span></p>
          </div>
          
          <!-- 鉄道インフラ -->
          <hr style="margin: 10px 0; border: none; border-top: 2px solid #333;" />
          <h3>🚆 鉄道インフラ</h3>
          <button
            id="btn-station-mode"
            onclick="toggleConstructionMode('station')"
          >
            🏠 駅モード (¥50M)
          </button>
          <button id="btn-track-mode" onclick="toggleConstructionMode('track')">
            🛤️ 路線モード
          </button>
          <button onclick="finalizeLine()" style="margin-top: 5px">
            ✅ 路線を確定
          </button>

          <!-- 航空インフラ -->
          <hr style="margin: 10px 0; border: none; border-top: 2px solid #007bff;" />
          <h3>✈️ 航空インフラ</h3>
          <button id="btn-airport-mode" onclick="toggleConstructionMode('airport')">
              ✈️ 空港モード (¥500M)
          </button>
          <button id="btn-air-route-mode" onclick="toggleConstructionMode('air-route')">
              🛬 航空路線モード
          </button>
          <button onclick="finalizeAirRoute()" style="margin-top: 5px">
              ✅ 航空路線を確定
          </button>

          <hr
            style="margin: 10px 0; border: none; border-top: 1px solid #ccc"
          />

          <!-- 解体モード -->
          <button
            id="btn-dismantle-station-mode"
            onclick="toggleConstructionMode('dismantle-station')"
            style="background-color: #ffc0cb"
          >
            💥 ターミナル解体モード
          </button>
          <button
            id="btn-dismantle-line-mode"
            onclick="toggleConstructionMode('dismantle-line')"
            style="background-color: #ffc0cb"
          >
            💣 路線/航空路線解体モード
          </button>

          <hr
            style="margin: 10px 0; border: none; border-top: 1px solid #ccc"
          />

          <button onclick="toggleConstructionMode('idle')">
            ❌ 建設キャンセル/アイドル
          </button>

          <hr
            style="margin: 10px 0; border: none; border-top: 1px solid #ccc"
          />

          <label style="display: block; margin-bottom: 5px; font-weight: bold"
            >線路/路線タイプ:</label
          >
          <select id="track-type" onchange="Game.currentTrackType = this.value">
            <option value="single">単線 (x1.0)</option>
            <option value="double">複線 (x1.8)</option>
            <option value="linear">リニア専用 (x5.0)</option>
            <option value="tram">路面電車専用 (x0.8)</option>
            <option value="air">航空路線 (建設費安)</option>
          </select>
        </div>
        <div id="vehicle-buy-container"></div>
      </div>
    </div>

    <!-- チャットパネル (右下) -->
    <div id="chat-panel">
      <div class="accordion-header" onclick="toggleAccordion('chat-content')">
        <span>💬 チャット <span id="chat-toggle-icon">▼</span></span>
      </div>
      <div id="chat-content" class="accordion-content open">
        <div id="chat-messages" style="height: 150px; overflow-y: auto; border: 1px solid #ccc; padding: 5px; margin-bottom: 5px; background-color: #f9f9f9;">
          <!-- メッセージがここに追加される -->
        </div>
        <input type="text" id="chat-input" placeholder="メッセージを入力..." maxlength="200" style="width: 70%; padding: 5px; box-sizing: border-box;">
        <button onclick="sendMessage()" style="width: 25%; margin-left: 5px; padding: 5px; box-sizing: border-box;">送信</button>
      </div>
    </div>

    <!-- ランキングパネル (チャットパネルの上) -->
    <div id="ranking-panel">
      <div
        class="accordion-header"
        onclick="toggleAccordion('ranking-content')"
      >
        <span
          >🏆 ランキング (総資産ベース)
          <span id="ranking-toggle-icon">▼</span></span
        >
      </div>
      <div id="ranking-content" class="accordion-content open">
        <ol id="ranking-list">
          <li>サーバーからデータを同期中...</li>
        </ol>
      </div>
    </div>

    <!-- エラーメッセージ表示領域 -->
    <div id="error-message" style="display: none"></div>
    <div id="info-message" style="display: none"></div>

     <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>

    <script>
      // =========================================================
      // A. ゲーム定数と状態 (クライアント側)
      // =========================================================
      const INITIAL_LAT = 35.681236;
      const INITIAL_LNG = 139.767125;
      const STATION_COST = 50000000;
      const AIRPORT_COST = 500000000; 
      const VEHICLE_BASE_COST = 8000000;
      const AIRPLANE_BASE_COST = 50000000; 

      let VehicleData = {};
      let map; 

      const Game = {
        userId: null,
        money: 0,
        totalConstructionCost: 0,
        currentLoan: 0, 
        monthlyRepayment: 0, 
        establishedLines: [],
        allLines: {}, 
        stations: [],
        airports: [], 
        vehicles: [],
        allVehicleMarkers: {}, 
        mode: "idle",
        currentTrackType: "single",
        
        _lastLineCount: 0,
        _lastVehicleCount: 0,

        updateStats(data) {
          this.money = data.money !== undefined ? data.money : this.money;
          this.totalConstructionCost =
            data.totalConstructionCost !== undefined
              ? data.totalConstructionCost
              : this.totalConstructionCost;
          this.currentLoan = data.currentLoan !== undefined ? data.currentLoan : this.currentLoan;
          this.monthlyRepayment = data.monthlyRepayment !== undefined ? data.monthlyRepayment : this.monthlyRepayment;
          this.establishedLines =
            data.establishedLines !== undefined
              ? data.establishedLines
              : this.establishedLines;
          this.vehicles =
            data.vehicles !== undefined ? data.vehicles : this.vehicles;

          if (data.stations || data.airports) this.drawTerminals(data.stations, data.airports);
          if (data.allLines) this.drawLines(data.allLines);

          this.updateFinancialUI();
        },
        
        updateFinancialUI() {
            // 資産計算 (サーバーのロジックに合わせるため、車両資産を推定)
            let totalVehicleAsset = 0;
            this.vehicles.forEach(v => {
                const data = VehicleData[v.dataKey];
                if (!data) return;
                const baseCost = data.category === 'air' ? AIRPLANE_BASE_COST : VEHICLE_BASE_COST;
                totalVehicleAsset += baseCost * data.purchaseMultiplier * (v.formationSize || 1);
            });
            
            // 総資産 = 資金 + 建設投資額 * 70% + 車両資産 * 30% - 負債
            const totalAsset =
                this.money +
                this.totalConstructionCost * 0.7 +
                totalVehicleAsset * 0.3 -
                this.currentLoan; 
                
            document.getElementById("money-display").textContent = `¥${Math.round(
                this.money
            ).toLocaleString()}`;
            document.getElementById("asset-display").textContent = `¥${Math.round(
                totalAsset
            ).toLocaleString()}`;
            document.getElementById("vehicle-count").textContent =
                this.vehicles.length;
            document.getElementById("current-loan-display").textContent = `¥${Math.round(
                this.currentLoan
            ).toLocaleString()}`;
            document.getElementById("loan-repayment-display").textContent = `¥${Math.round(
                this.monthlyRepayment
            ).toLocaleString()}`;
            
            // 融資可能額の更新 
            const maxLoan = Math.max(0, totalAsset * 0.5 - this.currentLoan);
            document.getElementById("max-loan-display").textContent = `¥${Math.round(maxLoan).toLocaleString()}`;
        },

        updateGlobalStats(data) {
          const gameTime = new Date(data.time);
          document.getElementById("game-date-time").textContent =
            this.formatDateTime(gameTime);
          document.getElementById(
            "time-scale-display"
          ).textContent = `x${data.globalStats.timeScale}`;
          document.getElementById("maint-cost-display").textContent = `¥${(
            data.globalStats.lastMonthlyMaintenance || 0
          ).toLocaleString()}`;
          document.getElementById("terminal-count").textContent =
            data.globalStats.stationsCount + data.globalStats.airportsCount;
            
          // ニュースフィードの更新
          if (data.globalStats.news) {
              this.addNewsItem(data.globalStats.news);
          }
            
          this.updateFinancialUI();
        },

        formatDateTime(date) {
          const year = date.getFullYear();
          const month = date.getMonth() + 1;
          const day = date.getDate();
          const hour = date.getHours().toString().padStart(2, "0");
          return `${year}年${month}月${day}日 ${hour}時`;
        },
        
        addNewsItem(message) {
            const newsList = document.getElementById('news-list');
            const li = document.createElement('li');
            const date = new Date();
            const timeString = `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
            li.innerHTML = `<small style="color: #888;">[${timeString}]</small> ${message}`;
            
            if (newsList.firstChild) {
                newsList.insertBefore(li, newsList.firstChild);
            } else {
                newsList.appendChild(li);
            }
            
            while (newsList.children.length > 10) {
                newsList.removeChild(newsList.lastChild);
            }
        },

        drawTerminals(stations, airports) {
          this.stations.forEach((s) => s.markers.forEach(m => map.removeLayer(m)));
          this.stations = [];
          
          this.airports.forEach((a) => a.markers.forEach(m => map.removeLayer(m)));
          this.airports = [];

          stations.forEach(
            (s) =>
              new Station(
                s.id,
                { lat: s.latlng[0], lng: s.latlng[1] },
                map,
                s.ownerId,
                s.type, 
                s.capacity,
                s.name, 
                s.demand,
                s.lineConnections,
                s.isOverloaded, 
                s.isDemandHigh 
              )
          );
          
          airports.forEach(
            (a) =>
              new Airport(
                a.id,
                { lat: a.latlng[0], lng: a.latlng[1] },
                map,
                a.ownerId,
                a.type, 
                a.capacity,
                a.name,
                a.lineConnections,
                a.isOverloaded 
              )
          );
        },

        drawLines(lines) {
          Object.values(this.allLines).forEach((polylines) => {
              polylines.forEach(p => map.removeLayer(p));
          });
          this.allLines = {};
          lines.forEach((line) => this.drawLine(line));
        },

        drawLine(line) {
          let weight = 8;
          let dashArray = null;
          let color = line.color;

          if (line.trackType === "double") weight = 12;
          else if (line.trackType === "linear") weight = 15;
          else if (line.trackType === "tram") weight = 6;
          else if (line.trackType === "air") {
              weight = 2;
              color = '#007bff';
              dashArray = '5, 10'; 
          }

          const isMyLine = line.ownerId === Game.userId;
          const finalStyle = {
            color: color,
            weight: isMyLine ? weight : weight * 0.7, 
            opacity: isMyLine ? 1 : 0.7, 
            lineCap: "round",
            dashArray: dashArray
          };
          
          const longitudeOffsets = [-360, 0, 360];
          const polylines = [];

          longitudeOffsets.forEach((offset) => {
            const offsetCoords = line.coords.map(coord => 
                L.latLng(coord[0], coord[1] + offset)
            );
            
            const polyline = L.polyline(offsetCoords, finalStyle).addTo(map);
            polylines.push(polyline);
          });
          
          this.allLines[line.id] = polylines;
        },
      };

      let socket;
      let drawingPolyline = null;
      let lineCandidateNodes = [];
      let currentConstructionCost = 0;
      let currentConstructionDistance = 0;

      // =========================================================
      // B. ターミナルクラス定義
      // =========================================================
      
      function getTerminalIconStyle(terminal, isAirport) {
        let baseClass = isAirport ? "airport-icon" : "station-icon";
        let colorClass = "normal";

        if (terminal.ownerId !== Game.userId) {
            return baseClass;
        }

        if (terminal.isOverloaded) {
            colorClass = "overload"; 
        } else if (terminal.isDemandHigh && !isAirport) {
            colorClass = "demand"; 
        }
        
        return `${baseClass} ${colorClass}`;
      }

      class Station {
        constructor(id, latlng, map, ownerId, type = 'Small', capacity = 3, name, demand, lineConnections = [], isOverloaded = false, isDemandHigh = false) {
          this.id = id;
          this.latlng = latlng;
          this.ownerId = ownerId;
          this.name = name; 
          this.type = type; 
          this.capacity = capacity; 
          this.demand = demand; 
          this.lineConnections = lineConnections; 
          this.isAirport = false;
          this.isOverloaded = isOverloaded; 
          this.isDemandHigh = isDemandHigh; 
          this.markers = []; 

          this.drawMarkers(map);
          Game.stations.push(this);
        }
        
        drawMarkers(map) {
            this.markers.forEach(m => map.removeLayer(m));
            this.markers = [];

            const iconClass = getTerminalIconStyle(this, false);
            
            const stationIcon = L.divIcon({
                className: iconClass,
                style: `background-color: ${this.ownerId === Game.userId ? '' : '#FF0000'};`,
            });
            
            const popupContent = this.generatePopupContent();
            const longitudeOffsets = [-360, 0, 360];

            longitudeOffsets.forEach((offset) => {
                const offsetLatLng = L.latLng(this.latlng.lat, this.latlng.lng + offset);
                const marker = L.marker(offsetLatLng, {
                    icon: stationIcon,
                    title: this.name, 
                }).addTo(map);

                marker.bindPopup(popupContent);
                
                marker.on("click", (e) => {
                    handleTerminalClick(this);
                    L.DomEvent.stopPropagation(e);
                    if (e.originalEvent) {
                        e.originalEvent.stopPropagation();
                    }
                });
                
                this.markers.push(marker);
            });

            this.marker = this.markers[1]; 
        }

        generatePopupContent() {
            let popupContent = `<b>🚆 駅: ${this.name} (ID: ${this.id})</b><br>Owner: ${this.ownerId}`;
            popupContent += `<br>種類: ${this.type} (容量: ${this.capacity}列車)`;
            
            if (this.isOverloaded) {
                popupContent += `<br><span style="color: red; font-weight: bold;">⚠️ 容量超過!</span>`;
            }
            
            if (this.lineConnections && this.lineConnections.length > 0) {
                popupContent += `<hr><b>接続路線: ${this.lineConnections.length}本</b>`;
            } else {
                popupContent += `<br>接続路線: なし`;
            }
            
            if (this.demand) {
                popupContent += `<hr><b>📊 需要</b><br>`;
                popupContent += `旅客: ${this.demand.passenger.toLocaleString()}人/月<br>`;
                popupContent += `貨物: ${this.demand.freight.toLocaleString()}t/月`;
            }
            
            if (this.ownerId === Game.userId) {
                const isMedium = this.type === 'Medium';
                const isLarge = this.type === 'Large';

                popupContent += `<hr>
                  <button onclick="upgradeStation(${this.id}, 'Medium')" ${isMedium || isLarge ? 'disabled' : ''} style="width: 100%; margin-bottom: 5px;">中規模にアップグレード (¥50M)</button>
                  <button onclick="upgradeStation(${this.id}, 'Large')" ${isLarge ? 'disabled' : ''} style="width: 100%;">大規模にアップグレード (${isMedium ? '¥100M' : '¥150M'})</button>`;
                
                popupContent += `<hr>
                  <label for="rename-input-${this.id}">駅名変更:</label>
                  <input type="text" id="rename-input-${this.id}" value="${this.name}" maxlength="20" style="width: 100%; margin: 5px 0;">
                  <button onclick="renameTerminalClient(${this.id}, false)" style="width: 100%;">駅名を変更</button>`;
            }
            return popupContent;
        }

        updatePopup() {
            this.drawMarkers(map);
        }
      }
      
      class Airport {
        constructor(id, latlng, map, ownerId, type = 'Small', capacity = 5, name, lineConnections = [], isOverloaded = false) {
          this.id = id;
          this.latlng = latlng;
          this.ownerId = ownerId;
          this.name = name; 
          this.type = type; 
          this.capacity = capacity; 
          this.lineConnections = lineConnections; 
          this.isAirport = true;
          this.isOverloaded = isOverloaded;
          this.markers = []; 

          this.drawMarkers(map);
          Game.airports.push(this);
        }

        drawMarkers(map) {
            this.markers.forEach(m => map.removeLayer(m));
            this.markers = [];

            const iconClass = getTerminalIconStyle(this, true);
            
            const airportIcon = L.divIcon({
                className: iconClass,
                html: '✈️',
                style: `background-color: ${this.ownerId === Game.userId ? '' : '#FF0000'};`,
            });
            
            const popupContent = this.generatePopupContent();
            const longitudeOffsets = [-360, 0, 360];

            longitudeOffsets.forEach((offset) => {
                const offsetLatLng = L.latLng(this.latlng.lat, this.latlng.lng + offset);
                const marker = L.marker(offsetLatLng, {
                    icon: airportIcon,
                    title: this.name, 
                }).addTo(map);

                marker.bindPopup(popupContent);
                
                marker.on("click", (e) => {
                    handleTerminalClick(this);
                    L.DomEvent.stopPropagation(e);
                    if (e.originalEvent) {
                        e.originalEvent.stopPropagation();
                    }
                });
                
                this.markers.push(marker);
            });

            this.marker = this.markers[1]; 
        }

        generatePopupContent() {
            let popupContent = `<b>✈️ 空港: ${this.name} (ID: ${this.id})</b><br>Owner: ${this.ownerId}`;
            popupContent += `<br>種類: ${this.type} (容量: ${this.capacity}機)`;
            
            if (this.isOverloaded) {
                popupContent += `<br><span style="color: red; font-weight: bold;">⚠️ 容量超過!</span>`;
            }
            
            if (this.lineConnections && this.lineConnections.length > 0) {
                popupContent += `<hr><b>接続路線: ${this.lineConnections.length}本</b>`;
            } else {
                popupContent += `<br>接続路線: なし`;
            }
            
            if (this.ownerId === Game.userId) {
                popupContent += `<hr>空港のアップグレード機能は未実装です。`;
                
                popupContent += `<hr>
                  <label for="rename-input-${this.id}">空港名変更:</label>
                  <input type="text" id="rename-input-${this.id}" value="${this.name}" maxlength="20" style="width: 100%; margin: 5px 0;">
                  <button onclick="renameTerminalClient(${this.id}, true)" style="width: 100%;">空港名を変更</button>`;
            }
            return popupContent;
        }

        updatePopup() {
            this.drawMarkers(map);
        }
      }

      // =========================================================
      // C. サーバー通信と認証
      // =========================================================

      function getCookie(name) {
        const nameEQ = name + "=";
        const ca = document.cookie.split(";");
        for (let i = 0; i < ca.length; i++) {
          let c = ca[i];
          while (c.charAt(0) === " ") c = c.substring(1, c.length);
          if (c.indexOf(nameEQ) === 0)
            return c.substring(nameEQ.length, c.length);
        }
        return null;
      }

      async function handleLogin() {
        const username = document.getElementById("username-input").value.trim();
        const password = document.getElementById("password-input").value.trim();

        if (username.length < 3 || password.length === 0) {
          alert("ユーザー名とパスワードを入力してください。");
          return;
        }

        try {
          const response = await fetch("/login", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ username: username, password: password }),
          });
          const data = await response.json();

          if (data.success) {
            Game.userId = data.userId;
            document.getElementById("login-overlay").style.display = "none";
            connectSocket(Game.userId);
          } else {
            alert("ログイン失敗: " + data.message);
          }
        } catch (error) {
          console.error("ログインエラー:", error);
          alert("サーバーとの通信に失敗しました。");
        }
      }

      function connectSocket(userId) {
        socket = io();

        socket.on("connect", () => {
          socket.emit("login", { userId: userId });
        });

        socket.on("initialState", (data) => {
          VehicleData = data.vehicleData;
          Game.updateStats(data);
          
          if (data.allLines) {
            Game.drawLines(data.allLines);
          }
          
          updateVehicleBuyUI();
          Game._lastLineCount = data.establishedLines ? data.establishedLines.length : 0;
          Game._lastVehicleCount = data.vehicles ? data.vehicles.length : 0;
        });

        socket.on("updateUserState", (data) => {
          Game.updateStats(data);
          
          const currentLineCount = data.establishedLines ? data.establishedLines.length : Game._lastLineCount;
          const currentVehicleCount = data.vehicles ? data.vehicles.length : Game._lastVehicleCount;

          if (currentLineCount !== Game._lastLineCount || currentVehicleCount !== Game._lastVehicleCount) {
              updateVehicleBuyUI();
              Game._lastLineCount = currentLineCount;
              Game._lastVehicleCount = currentVehicleCount;
          }
        });

        socket.on("gameUpdate", (data) => {
          Game.updateGlobalStats(data);
          updateVehiclePositions(data.vehiclePositions);
        });

        socket.on("rankingUpdate", (ranking) => {
          updateRankingUI(ranking);
        });

        socket.on("terminalUpdate", (data) => {
            const terminalArray = data.isAirport ? Game.airports : Game.stations;
            const terminal = terminalArray.find(t => t.id === data.id);
            
            if (terminal) {
                if (data.isOverloaded !== undefined) terminal.isOverloaded = data.isOverloaded;
                if (data.isDemandHigh !== undefined) terminal.isDemandHigh = data.isDemandHigh;
                if (data.lineConnections !== undefined) terminal.lineConnections = data.lineConnections;
                if (data.demand !== undefined) terminal.demand = data.demand;
                
                terminal.updatePopup();
            }
        });

        socket.on("stationBuilt", (data) => {
          new Station(data.id, { lat: data.latlng[0], lng: data.latlng[1] }, map, data.ownerId, data.type, data.capacity, data.name, data.demand, data.lineConnections || []); 
          Game.updateGlobalStats({ globalStats: { stationsCount: Game.stations.length, airportsCount: Game.airports.length } });
        });
        
        socket.on("airportBuilt", (data) => {
          new Airport(data.id, { lat: data.latlng[0], lng: data.latlng[1] }, map, data.ownerId, data.type, data.capacity, data.name, data.lineConnections || []); 
          Game.updateGlobalStats({ globalStats: { stationsCount: Game.stations.length, airportsCount: Game.airports.length } });
        });
        
        socket.on("stationUpgraded", (data) => {
          const station = Game.stations.find(s => s.id === data.id);
          if (station) {
              station.type = data.type;
              station.capacity = data.capacity;
              station.updatePopup();
          }
        });
        
        socket.on("terminalRenamed", (data) => {
            let terminal;
            if (data.isAirport) {
                terminal = Game.airports.find(s => s.id === data.id);
            } else {
                terminal = Game.stations.find(s => s.id === data.id);
            }
            
            if (terminal) {
                terminal.name = data.newName;
                terminal.updatePopup(); 
            }
        });

        socket.on("lineBuilt", (data) => {
          Game.drawLine(data);
        });

        socket.on("lineDismantled", (data) => {
          if (Game.allLines[data.lineId]) {
            Game.allLines[data.lineId].forEach(p => map.removeLayer(p));
            delete Game.allLines[data.lineId];
          }
        });

        socket.on("stationDismantled", (data) => {
          let terminalArray = data.isAirport ? Game.airports : Game.stations;
          
          const terminalIndex = terminalArray.findIndex(
            (s) => s.id === data.terminalId
          );
          if (terminalIndex !== -1) {
            terminalArray[terminalIndex].markers.forEach(m => map.removeLayer(m));
            terminalArray.splice(terminalIndex, 1);
          }
          Game.updateGlobalStats({ globalStats: { stationsCount: Game.stations.length, airportsCount: Game.airports.length } });
        });

        socket.on("error", (message) => {
          const errorDiv = document.getElementById("error-message");
          errorDiv.textContent = message;
          errorDiv.style.display = "block";
          setTimeout(() => {
            errorDiv.style.display = "none";
          }, 5000);
        });

        socket.on("info", (message) => {
          const infoDiv = document.getElementById("info-message");
          infoDiv.textContent = message;
          infoDiv.style.display = "block";
          setTimeout(() => {
            infoDiv.style.display = "none";
          }, 5000);
        });
        
        socket.on("chatHistory", (history) => {
            const chatMessages = document.getElementById('chat-messages');
            chatMessages.innerHTML = ''; 
            history.forEach(msg => {
                appendChatMessage(msg.userId, msg.message, msg.timestamp);
            });
        });

        socket.on("newMessage", (data) => {
            appendChatMessage(data.userId, data.message, data.timestamp);
        });
      }

      function updateVehiclePositions(vehiclePositions) {
        const longitudeOffsets = [-360, 0, 360];
        const existingVehicleIds = new Set(Object.keys(Game.allVehicleMarkers));

        vehiclePositions.forEach((vehicle) => {
          if (!Array.isArray(vehicle.latlng) || vehicle.latlng.length !== 2) {
              console.warn(`車両ID ${vehicle.id} の位置情報が不正です:`, vehicle.latlng);
              return; 
          }

          const latlng = L.latLng(vehicle.latlng[0], vehicle.latlng[1]);
          existingVehicleIds.delete(vehicle.id.toString());

          if (!Game.allVehicleMarkers[vehicle.id]) {
            Game.allVehicleMarkers[vehicle.id] = { original: null, copies: [] };
          }

          const markerData = Game.allVehicleMarkers[vehicle.id];
          
          const isAir = vehicle.category === 'air';
          const iconClass = isAir ? "airplane-icon" : "train-icon";
          
          const rotationAngle = vehicle.rotation !== undefined ? vehicle.rotation : 0;
          
          const rotationStyle = isAir 
            ? `transform: translate(-50%, -50%) rotate(${rotationAngle}deg);`
            : `transform: translate(-50%, -50%);`;

          const markerIcon = L.divIcon({
            className: iconClass,
            style: `background-color: ${vehicle.color}; border-color: ${
              vehicle.owner === Game.userId ? "yellow" : "white"
            }; ${rotationStyle}`,
          });
          const popupContent = `${isAir ? '✈️' : '🚆'} 車両 #${vehicle.id} (Owner: ${vehicle.owner}) - Status: ${vehicle.status || 'Running'} (編成数: ${vehicle.formationSize || 1})`;

          longitudeOffsets.forEach((offset, index) => {
            const offsetLatLng = L.latLng(latlng.lat, latlng.lng + offset);
            let currentMarkerData;

            if (index === 1) { 
              currentMarkerData = markerData.original;
            } else { 
              const copyIndex = index === 0 ? 0 : 1;
              currentMarkerData = markerData.copies[copyIndex];
            }

            if (!currentMarkerData) {
                marker = L.marker(offsetLatLng, { icon: markerIcon }).addTo(map);
                marker.bindPopup(popupContent);
                
                if (index === 1) {
                    markerData.original = marker;
                } else {
                    const copyIndex = index === 0 ? 0 : 1;
                    markerData.copies[copyIndex] = marker;
                }
            } else {
                currentMarkerData.setLatLng(offsetLatLng);
                currentMarkerData.setPopupContent(popupContent);
                
                const newIcon = L.divIcon({
                    className: iconClass,
                    style: `background-color: ${vehicle.color}; border-color: ${
                        vehicle.owner === Game.userId ? "yellow" : "white"
                    }; ${rotationStyle}`, 
                });
                currentMarkerData.setIcon(newIcon);
            }
          });
        });

        existingVehicleIds.forEach(vehicleId => {
            const markerData = Game.allVehicleMarkers[vehicleId];
            if (markerData.original) map.removeLayer(markerData.original);
            markerData.copies.forEach(copy => {
                if (copy) map.removeLayer(copy); 
            });
            delete Game.allVehicleMarkers[vehicleId];
        });
      }

      function updateRankingUI(ranking) {
        const list = document.getElementById("ranking-list");
        list.innerHTML = "";
        ranking.forEach((item, index) => {
          const li = document.createElement("li");
          li.innerHTML = `${index + 1}. <b>${item.userId}</b>: ¥${Math.round(
            item.score
          ).toLocaleString()}`;
          if (item.userId === Game.userId) {
            li.style.fontWeight = "bold";
            li.style.color = "#0044BB";
          }
          list.appendChild(li);
        });
      }

      // =========================================================
      // D. 建設・解体ロジック (サーバーにコマンド送信)
      // =========================================================

       function handleStationCreation(e) {
        if (Game.mode !== "station" || !socket) return;
        socket.emit("buildStation", { latlng: [e.latlng.lat, e.latlng.lng] });
      }
      
      function handleAirportCreation(e) {
        if (Game.mode !== "airport" || !socket) return;
        socket.emit("buildAirport", { latlng: [e.latlng.lat, e.latlng.lng] });
      }

      function handleTerminalDismantle(terminal) {
        if (Game.mode !== "dismantle-station" || !socket) return;

        if (terminal.ownerId !== Game.userId) {
          alert("自分のターミナルしか解体できません。");
          return;
        }
        
        const cost = terminal.isAirport ? AIRPORT_COST : STATION_COST;
        const dismantleCost = Math.round(cost * 0.1);
        
        const type = terminal.isAirport ? '空港' : '駅';

        if (
          confirm(
            `${type} ${terminal.name} (ID: ${terminal.id}) を解体しますか？ (費用: ¥${dismantleCost.toLocaleString()})`
          )
        ) {
          socket.emit("dismantleTerminal", { terminalId: terminal.id, isAirport: terminal.isAirport });
        }
      }

      function handleTerminalClick(terminal) {
        if (Game.mode === "track") {
            if (terminal.isAirport) {
                alert("鉄道路線は空港をノードにできません。");
                return;
            }
            handleTrackNodeClick(terminal);
        } else if (Game.mode === "air-route") {
            handleAirRouteNodeClick(terminal);
        } else if (Game.mode === "dismantle-station") {
            handleTerminalDismantle(terminal);
        }
      }
      
      function handleTrackNodeClick(station) {
        if (station.ownerId !== "ADMIN_SHARED"){
          if (station.ownerId !== Game.userId) {
            alert("他プレイヤーの駅は路線のノードとして使用できません。");
            return;
          }
        }
          if (lineCandidateNodes.includes(station)) return;

          lineCandidateNodes.push(station);
          updateDrawingPolyline(Game.currentTrackType);
      }
      
      function handleAirRouteNodeClick(terminal) {
          if (terminal.ownerId !== Game.userId && terminal.ownerId !== "ADMIN_SHARED") {
            alert("他プレイヤーの施設はノードとして使用できません。");
            return;
          }

          if (lineCandidateNodes.includes(terminal)) return;

          lineCandidateNodes.push(terminal);
          updateDrawingPolyline('air');
      }
      
      function updateConstructionInfo(trackType) {
          const infoDiv = document.getElementById("construction-info");
          
          if (lineCandidateNodes.length < 2) {
              infoDiv.style.display = 'none';
              currentConstructionCost = 0;
              currentConstructionDistance = 0;
              return;
          }
          
          infoDiv.style.display = 'block';
          
          const coords = lineCandidateNodes.map(t => [t.latlng.lat, t.latlng.lng]);
          
          socket.emit('calculateConstructionCost', { coords: coords, trackType: trackType }, (result) => {
              if (result.success) {
                  currentConstructionCost = result.totalCost;
                  currentConstructionDistance = result.totalLengthKm;
                  
                  document.getElementById("construction-distance").textContent = `${currentConstructionDistance.toFixed(2)} km`;
                  document.getElementById("construction-cost").textContent = `¥${Math.round(currentConstructionCost).toLocaleString()}`;
                  
                  const terrainPercent = ((result.avgTerrainMultiplier - 1) * 100).toFixed(1);
                  document.getElementById("construction-terrain").textContent = `${terrainPercent}%`;
              }
          });
      }
      
      function updateDrawingPolyline(trackType) {
          const currentCoords = lineCandidateNodes.map((t) => [
            t.latlng.lat,
            t.latlng.lng,
          ]);

          if (currentCoords.length >= 2) {
            let weight = 7;
            let dashArray = "10, 10";
            let color = "#C0C0C0";
            
            if (trackType === "double") weight = 12;
            else if (trackType === "linear") weight = 15;
            else if (trackType === "tram") weight = 6;
            else if (trackType === "air") {
                weight = 2;
                color = "#007bff";
                dashArray = "5, 10";
            }

            if (drawingPolyline) {
              drawingPolyline
                .setLatLngs(currentCoords)
                .setStyle({ color: color, weight: weight, dashArray: dashArray });
            } else {
              drawingPolyline = L.polyline(currentCoords, {
                color: color,
                weight: weight,
                opacity: 0.8,
                dashArray: dashArray,
              }).addTo(map);
            }
          }
          
          updateConstructionInfo(trackType);
      }

      function finalizeLine() {
        if (lineCandidateNodes.length < 2 || !socket) {
          alert("路線には2つ以上の駅が必要です。");
          return;
        }
        
        if (lineCandidateNodes.some(t => t.isAirport)) {
            alert("鉄道路線には空港を含めることはできません。航空路線確定ボタンを使用してください。");
            return;
        }

        const stationCoords = lineCandidateNodes.map((s) => [
          s.latlng.lat,
          s.latlng.lng,
        ]);

        socket.emit("buildLine", {
          terminalCoords: stationCoords,
          trackType: Game.currentTrackType,
        });

        resetLineDrawing();
        toggleConstructionMode("idle");
      }
      
      function finalizeAirRoute() {
        if (lineCandidateNodes.length < 2 || !socket) {
          alert("航空路線には2つ以上のターミナルが必要です。");
          return;
        }
        
        const terminalCoords = lineCandidateNodes.map((t) => [
          t.latlng.lat,
          t.latlng.lng,
        ]);

        socket.emit("buildLine", {
          terminalCoords: terminalCoords,
          trackType: 'air',
        });

        resetLineDrawing();
        toggleConstructionMode("idle");
      }
      
      function resetLineDrawing() {
        if (drawingPolyline) map.removeLayer(drawingPolyline);
        lineCandidateNodes = [];
        drawingPolyline = null;
        document.getElementById("construction-info").style.display = 'none';
        currentConstructionCost = 0;
        currentConstructionDistance = 0;
      }

      window.upgradeStation = (stationId, newType) => {
        if (!socket) return alert("サーバーに接続されていません。");
        
        const station = Game.stations.find(s => s.id === stationId);
        if (!station) return;

        let cost = 0;
        const currentType = station.type;

        if (newType === 'Medium' && currentType === 'Small') {
            cost = 50000000; 
        } else if (newType === 'Large' && currentType === 'Small') {
            cost = 150000000; 
        } else if (newType === 'Large' && currentType === 'Medium') {
            cost = 100000000; 
        } else {
            return; 
        }

        if (confirm(`${station.name} を ${newType} 駅にアップグレードしますか？ (費用: ¥${cost.toLocaleString()})`)) {
            socket.emit("upgradeStation", { stationId: stationId, newType: newType, cost: cost });
        }
      };
      
      window.renameTerminalClient = (terminalId, isAirport) => {
        if (!socket) return alert("サーバーに接続されていません。");
        
        const input = document.getElementById(`rename-input-${terminalId}`);
        const newName = input ? input.value.trim() : null;
        
        if (!newName || newName.length < 2 || newName.length > 20) {
            return alert("名称は2文字以上20文字以内で入力してください。");
        }

        socket.emit("renameTerminal", { terminalId: terminalId, newName: newName, isAirport: isAirport });
      };
      
      window.requestLoan = () => {
          if (!socket) return alert("サーバーに接続されていません。");
          
          const amountM = parseFloat(document.getElementById('loan-amount-input').value);
          const termMonths = parseInt(document.getElementById('loan-term-input').value);
          
          if (isNaN(amountM) || amountM <= 0 || isNaN(termMonths) || termMonths < 6) {
              return alert("借入額は正の値で、期間は6ヶ月以上に設定してください。");
          }
          
          const amount = Math.round(amountM * 1000000);
          
          if (amount > Game.money * 10) { 
              if (!confirm(`借入額 ¥${amount.toLocaleString()} は現在の資金の10倍以上です。本当に借りますか？`)) {
                  return;
              }
          }
          
          socket.emit('requestLoan', { amount: amount, termMonths: termMonths });
      };

      function handleLineDismantle(e) {
        if (Game.mode !== "dismantle-line" || !socket) return;

        let closestLineId = null;
        let minDistance = Infinity;
        const lineSearchRadiusKm = 0.05; 

        const clickPoint = turf.point([e.latlng.lng, e.latlng.lat]);

        Object.entries(Game.allLines).forEach(([lineId, polylines]) => {
          polylines.forEach(polyline => {
              if (!polyline) return;

              const latlngs = polyline.getLatLngs();
              const coords = latlngs.map(ll => [ll.lng, ll.lat]);
              
              if (coords.length < 2) return;

              const line = turf.lineString(coords);
              
              const distanceKm = turf.pointToLineDistance(clickPoint, line, { units: 'kilometers' });
              
              if (distanceKm < minDistance && distanceKm < lineSearchRadiusKm) {
                  minDistance = distanceKm;
                  closestLineId = lineId;
              }
          });
        });


        if (!closestLineId) {
          alert("クリックした位置の近くに解体できる路線が見つかりません。");
          return;
        }

        const lineData = Game.establishedLines.find((l) => l.id == closestLineId);

        if (!lineData || lineData.ownerId !== Game.userId) {
          alert("自分の路線/航空路線のみ解体可能です。");
          return;
        }

        const dismantleCost = Math.round(lineData.cost * 0.1);
        if (
          confirm(
            `路線 ${closestLineId} を解体しますか？ (費用: ¥${dismantleCost.toLocaleString()}、車両は購入価格の1/3で自動売却されます)`
          )
        ) {
          socket.emit("dismantleLine", { lineId: parseInt(closestLineId) });
        }
      }


      // =========================================================
      // E. UIとイベント処理
      // =========================================================

      function toggleConstructionMode(newMode) {
        const mapContainer = map.getContainer();

        L.DomUtil.removeClass(mapContainer, "station-mode");
        L.DomUtil.removeClass(mapContainer, "airport-mode");
        L.DomUtil.removeClass(mapContainer, "track-mode");
        L.DomUtil.removeClass(mapContainer, "air-route-mode");
        L.DomUtil.removeClass(mapContainer, "dismantle-station-mode");
        L.DomUtil.removeClass(mapContainer, "dismantle-line-mode");

        map.off("click", handleStationCreation);
        map.off("click", handleAirportCreation);
        map.off("click", handleLineDismantle);

        resetLineDrawing();

        Game.mode = newMode;

        document
          .querySelectorAll(".rail-ui-control button")
          .forEach((btn) => btn.classList.remove("active"));

        if (newMode === "station") {
          L.DomUtil.addClass(mapContainer, "station-mode");
          document.getElementById("btn-station-mode").classList.add("active");
          map.on("click", handleStationCreation);
          Game.currentTrackType = "single";
        } else if (newMode === "airport") {
          L.DomUtil.addClass(mapContainer, "airport-mode");
          document.getElementById("btn-airport-mode").classList.add("active");
          map.on("click", handleAirportCreation);
          Game.currentTrackType = "air";
        } else if (newMode === "track") {
          L.DomUtil.addClass(mapContainer, "track-mode");
          document.getElementById("btn-track-mode").classList.add("active");
          Game.currentTrackType = "single";
        } else if (newMode === "air-route") {
          L.DomUtil.addClass(mapContainer, "air-route-mode");
          document.getElementById("btn-air-route-mode").classList.add("active");
          Game.currentTrackType = "air";
        } else if (newMode === "dismantle-station") {
          L.DomUtil.addClass(mapContainer, "dismantle-station-mode");
          document
            .getElementById("btn-dismantle-station-mode")
            .classList.add("active");
        } else if (newMode === "dismantle-line") {
          L.DomUtil.addClass(mapContainer, "dismantle-line-mode");
          document
            .getElementById("btn-dismantle-line-mode")
            .classList.add("active");
          map.on("click", handleLineDismantle);
        } else {
          // アイドルの場合、駅モードボタンをアクティブにする (デフォルト)
          document.getElementById("btn-station-mode").classList.add("active"); 
          Game.currentTrackType = "single";
        }
        
        const trackTypeSelect = document.getElementById("track-type");
        if (trackTypeSelect) {
            trackTypeSelect.value = Game.currentTrackType;
        }
      }

      function updateVehicleBuyUI() {
        const container = document.getElementById("vehicle-buy-container");
        container.innerHTML = `<h4>🚆✈️ 車両/飛行機購入・路線割当</h4>`;

        if (Game.establishedLines.length === 0) {
          container.innerHTML += `<p>路線/航空路線を建設すると車両/飛行機が購入できます。</p>`;
          return;
        }

        if (Object.keys(VehicleData).length === 0) {
          container.innerHTML += `<p>車両データをサーバーから取得中...</p>`;
          return;
        }

        const sortedVehicleKeys = Object.keys(VehicleData).sort(
          (a, b) =>
            VehicleData[a].purchaseMultiplier -
            VehicleData[b].purchaseMultiplier
        );

        sortedVehicleKeys.forEach((key) => {
          const data = VehicleData[key];
          const isAir = data.category === 'air';
          const baseCost = isAir ? AIRPLANE_BASE_COST : VEHICLE_BASE_COST;
          const purchaseCost = baseCost * data.purchaseMultiplier; // 単編成コスト
          const icon = isAir ? '✈️' : '🚆';
          const maxFormation = data.maxFormation || 1;

          const availableLines = Game.establishedLines.filter((line) => {
            const isLinear = data.name.includes("リニア");
            
            if (isAir) {
                return line.trackType === 'air';
            }
            
            if (line.trackType === 'air') return false; 
            
            if (isLinear) return line.trackType === "linear";
            if (line.trackType === "linear") return false;

            return true;
          });

          const lineSelect = `<select id="line-select-${key}" style="width: 35%; margin-right: 5px; margin-top: 5px;">
                    ${availableLines
                      .map(
                        (line) =>
                          `<option value="${line.id}">L${line.id} (${line.trackType === 'air' ? '航空' : line.trackType})</option>`
                      )
                      .join("")}
                </select>`;

          const disabled = availableLines.length === 0 ? "disabled" : "";

          container.innerHTML += `
                    <div style="display: flex; flex-wrap: wrap; align-items: center; margin-bottom: 5px; border-bottom: 1px dotted #ccc; padding-bottom: 5px;">
                        <span style="width: 100%; font-weight: bold; color: ${data.color};">${icon} ${
            data.name
          }</span>
                        <small style="width: 100%; margin-bottom: 5px;">${
                          data.maxSpeedKmH
                        }km/h, ¥${purchaseCost.toLocaleString()} (単編成)</small>
                        
                        ${lineSelect}
                        <input type="number" id="formation-input-${key}" min="1" max="${maxFormation}" value="1" style="width: 30%; margin-right: 5px;" title="編成数 (最大${maxFormation})">
                        <button onclick="buyVehicle('${key}')" style="width: 25%;" ${disabled}>購入</button>
                    </div>
                `;
        });
      }

      window.buyVehicle = (vehicleKey) => {
        if (!socket) return alert("サーバーに接続されていません。");
        const lineSelect = document.getElementById(`line-select-${vehicleKey}`);
        const formationInput = document.getElementById(`formation-input-${vehicleKey}`);
        
        if (!lineSelect || lineSelect.value === "") {
          alert("割り当てる路線を選択してください。");
          return;
        }
        
        const lineId = lineSelect.value;
        const formationSize = parseInt(formationInput ? formationInput.value : 1, 10);
        
        if (formationSize < 1 || isNaN(formationSize)) {
            alert("編成数は1以上である必要があります。");
            return;
        }

        socket.emit("buyVehicle", { lineId: lineId, vehicleKey: vehicleKey, formationSize: formationSize });
      };

      window.toggleAccordion = (contentId) => {
        const content = document.getElementById(contentId);
        const header = content.previousElementSibling;
        const icon = header.querySelector("span:last-child");

        const isOpen = content.classList.toggle("open");
        
        if (isOpen) {
          icon.textContent = "▼";
          // max-heightを計算して設定
          content.style.maxHeight = content.scrollHeight + "px"; 
        } else {
          icon.textContent = "▲";
          content.style.maxHeight = "0";
        }
      };
      
      function appendChatMessage(userId, message, timestamp) {
        const chatMessages = document.getElementById('chat-messages');
        const messageElement = document.createElement('p');
        messageElement.style.margin = '2px 0';
        messageElement.style.wordBreak = 'break-word';
        
        const date = new Date(timestamp);
        const timeString = `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
        
        messageElement.innerHTML = `<small style="color: #888;">[${timeString}]</small> <b>${userId}</b>: ${message}`;
        
        chatMessages.appendChild(messageElement);
        chatMessages.scrollTop = chatMessages.scrollHeight; 
      }

      function sendMessage() {
        const input = document.getElementById('chat-input');
        const message = input.value;
        
        if (!message.trim()) return;
        
        if (socket) {
            socket.emit('sendMessage', { message: message });
            input.value = '';
        }
      }

      window.sendMessage = sendMessage;
      window.handleLogin = handleLogin;
      window.toggleConstructionMode = toggleConstructionMode;
      window.finalizeLine = finalizeLine;
      window.finalizeAirRoute = finalizeAirRoute;
      window.Game = Game;
      window.handleTerminalClick = handleTerminalClick;

      document.addEventListener("DOMContentLoaded", () => {
        map = L.map("map", {
            worldCopyJump: true 
        }).setView([INITIAL_LAT, INITIAL_LNG], 13);
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "© OpenStreetMap contributors (Base)",
          maxZoom: 19,
          minzoom: 2,
        }).addTo(map);
        L.tileLayer(
          "https://cyberjapandata.gsi.go.jp/xyz/dem5a_color/{z}/{x}/{y}.png",
          { attribution: "国土地理院", opacity: 0.5 }
        ).addTo(map);

        // モバイル対応のため、UIコントロールをマップ外に配置
        const controlDiv = document.querySelector(".rail-ui-control");
        const controlHtml = controlDiv.innerHTML;
        controlDiv.remove();

        // Leafletコントロールとして再配置 (PC向け)
        if (window.innerWidth > 650) {
            const constructControl = L.control({ position: "topleft" });
            constructControl.onAdd = function (map) {
              const div = L.DomUtil.create("div", "rail-ui-control");
              div.innerHTML = controlHtml;
              L.DomEvent.disableClickPropagation(div);
              
              const trackTypeSelect = div.querySelector("#track-type");
              if (trackTypeSelect) {
                  trackTypeSelect.value = Game.currentTrackType;
              }
              
              return div;
            };
            constructControl.addTo(map);
        } else {
            // モバイルの場合は、body直下に再挿入された要素がそのまま使用される
            document.querySelector('.rail-ui-control').innerHTML = controlHtml;
        }

        toggleConstructionMode("idle");

        const savedUserId = getCookie("userId");
        if (savedUserId) {
          document.getElementById("username-input").value = savedUserId;
        }
        
        const chatInput = document.getElementById('chat-input');
        if (chatInput) {
            chatInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
        }
      });
    </script>
  </body>
